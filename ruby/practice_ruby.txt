===========================================================Ruby Practice====================================================
1. Object oriented programming language:

    Data Encapsulation
    Data Abstraction
    Polymorphism
    Inheritance


3.variable :

	1.Local variable: define in a methods,not available outside the methods,begine with lowercase letter or '_'
	2.instance variable:available across the methods for any particular instance that means instance variable change object to object.
					denoted like : @variablename
	3.class variable:Class variables are available across different objects. A class variable belongs to the class and is a characteristic of a cl                        ass. They are preceded by the sign @@ and are followed by the variable name.
	4.global variable: Class variables are not available across classes. If you want to have a single variable, which is available across classes,				 you need to define a global variable. The global variables are always preceded by the dollar sign ($).


2.Methods:
 
how to define :

 class Sample
    def hello                     #this is the definition of a methods. 
        puts "method learning"
    end
end                               #termination of class.

object  = Sample. new
object.hello

output : ruby classcust.rb
method learning


3.Methods and class 

$global_variable = 10
class Class1
  def print_global
    puts "Global variable in class 1 is #$global_variable"
  end
end

class Class2
  def print_global
    puts "Global variable in class 2 #$global_varible is #$global_variable"
  end
end

class1Object = Class1.new
class1Object.print_global
class2Object = Class2.new
class2Object.print_global


4.classes and object practice :
  variable practice:

code : 

$globalVariable = 10            # global variable defination here

class Sample                      # class is deinfined here

  @@class_variable = 100          # class variable
  def methodscall(val1,val2,val3)
    @value_call_first = val1
    @value_call_second = val2
    @value_call_third = val3
    puts "methods var "
    local_variable = "I am local" # local variable is here
    puts "local variable data :  #local_variable"
  end

end

object = Sample.new
object.methodscall(1,"calling","Great")
puts "global variable : #$globalVariable"

output : ruby program.rb 
methods var 
local variable data :  #local_variable
global variable : 10


5. Method calling 

code : class Sample                      # class is deinfined here
   
  # instance variable example how I can call them
  def methodscall(val1,val2,val3)
    @value_call_first = val1
    @value_call_second = val2
    @value_call_third = val3

  puts "value for val1 : #@value_call_first"
  puts "value for val2 : #@value_call_second"
  puts "value for val2 : #@value_call_third"
  end
  
end

object = Sample.new
object.methodscall("1","calling","Great")


output : 

ruby customclass.rb 
value for val1 : 1
value for val2 : calling
value for val2 : Great


6. class variable

class Customer
   @@no_of_customers = 0
   def initialize(id, name, addr)
      @cust_id = id
      @cust_name = name
      @cust_addr = addr
   end
   def display_details()
      puts "Customer id #@cust_id"
      puts "Customer name #@cust_name"
      puts "Customer address #@cust_addr"
   end
   def total_no_of_customers()
      @@no_of_customers += 1
      puts "Total number of customers: #@@no_of_customers"
   end
end

# Create Objects
cust1 = Customer.new("1", "John", "Wisdom Apartments, Ludhiya")
cust2 = Customer.new("2", "Poul", "New Empire road, Khandala")

# Call Methods
cust1.total_no_of_customers()
cust2.total_no_of_customers()

output : 
ruby classvariable.rb 
Total number of customers: 1
Total number of customers: 2


7. Instance Variable 

class Customer
   def initialize(id, name, addr)
      @cust_id = id
      @cust_name = name
      @cust_addr = addr
   end
   def display_details()
      puts "Customer id #@cust_id"
      puts "Customer name #@cust_name"
      puts "Customer address #@cust_addr"
   end
end

# Create Objects
cust1 = Customer.new("1", "Aman", "Faridabad")
cust2 = Customer.new("2", "Neha", "Delhi")

# Call Methods
cust1.display_details()
cust2.display_details()

output : 

ruby instancevariable.rb 
Customer id 1
Customer name Aman
Customer address Faridabad
Customer id 2
Customer name Neha
Customer address Delhi

8. Global variable :

code :

$global_variable = 10
class Class1
   def print_global
      puts "Global variable in Class1 is #$global_variable"
   end
end
class Class2
   def print_global
      puts "Global variable in Class2 is #$global_variable"
   end
end

class1obj = Class1.new
class1obj.print_global
class2obj = Class2.new
class2obj.print_global

ruby globalvar.rb 
Global variable in class 1 is 10
Global variable in class 2  is 10

=========================================================Conditional statements=============================================================

1.If statement: 
syntax : 

	if conditional [then]
   		code...
	[elsif conditional [then]
   		code...]...	
	[else
   		code...]
	end
example : x = 1
if x > 2
   puts "x is greater than 2"
elsif x <= 2 and x!=0
   puts "x is 1"
else
   puts "I can't guess the number"
end


2. if modifier:

syntax : code if condition

code : 
$debug = 1
print "debug\n" if $debug


3.Ruby Unless statement:

syntax : 

unless conditional [then]
   code
[else
   code ]
end

code : 

x = 1
unless x>=2
 puts "x is less than 2"
else
 puts "x is greater than 2"
 
 4.switch statement:
 
 syntax : 
 case expr0
when expr1, expr2
   stmt1
when expr3, expr4
   stmt2
else
   stmt3
end

code : 

$age =  5
case $age
when 0 .. 2
   puts "baby"
when 3 .. 6
   puts "little child"
when 7 .. 12
   puts "child"
when 13 .. 18
   puts "youth"
else
   puts "adult"
end


output : little child

============================================================loop=======================================================
1.while loop:

syntax : 
while conditional [do]
   code
end

code : 

$i = 0
$num = 5

while $i < $num  do
   puts("Inside the loop i = #$i" )
   $i +=1
end

2.while modifier:

syntax : 

code while condition

OR

begin nu
  code 
end while conditional

code : 
$i = 0
$num = 5
begin
   puts("Inside the loop i = #$i" )
   $i +=1
end while $i < $num

3. Untill statement:

syntax : 
until conditional [do]
   code
end

code : 

$i = 0
$num = 5

until $i>$num
  puts "inside the loop until i = #$i"
  $i+=1
end

=begin 
output:
inside the loop until i = 0
inside the loop until i = 1
inside the loop until i = 2
inside the loop until i = 3
inside the loop until i = 4
inside the loop until i = 5

=end

4.until modifier:

syntax :

code until conditional

OR

begin
   code
end until conditional

code : 
$i=0
$num = 10

begin
  puts "inside the loop i = #$i"
  $i+=1
end until $i>$num

=begin 

output: 

inside the loop i = 0
inside the loop i = 1
inside the loop i = 2
inside the loop i = 3
inside the loop i = 4
inside the loop i = 5
inside the loop i = 6
inside the loop i = 7
inside the loop i = 8
inside the loop i = 9
inside the loop i = 10
=end

5.Ruby statements:

syntax : 
for variable [, variable ...] in expression [do]
   code
end

code :
 for i in 0..10
  puts "values of local variable is #{i}"
end

=begin 
output :

values of local variable is 0
values of local variable is 1
values of local variable is 2
values of local variable is 3
values of local variable is 4
values of local variable is 5
values of local variable is 6
values of local variable is 7
values of local variable is 8
values of local variable is 9
values of local variable is 10


=end 
6.Break statement:

syntax : break 

code : 
for i in 0..5
  if i > 2 then
    break
  end
  puts"values of local variable is #{i}"
end

=begin 
output:

values of local variable is 0
values of local variable is 1
values of local variable is 2

=end
7.next : Jumps to the next iteration of the most internal loop. Terminates execution of a block if called within a block (with yield or call returning nil).

syntax : next

code : 
for i in 0..5
  if i<3 then
    next
  end
  puts "value of local variable is #{i}"
end

=begin
output:

value of local variable is 3
value of local variable is 4
value of local variable is 5

=end

8.redo : Restarts this iteration of the most internal loop, without checking loop condition. Restarts yield or call if called within a block.

syntax : redo 

code :

for i in 0..5
  if i<2 then
    puts"vale of local variable is #{i}"
    redo
  end
end

=begin
output :

vale of local variable is 0
vale of local variable is 0
vale of local variable is 0
vale of local variable is 0
vale of local variable is 0
.......................... infinite loop
=end

9.retry : If retry appears in rescue clause of begin expression, restart from the beginning of the begin body.

syntax : retry

code : 

for i in 0..10
        begin
                puts "VALUE OF i #{i}"
                raise if i >=9
                rescue
                retry
        end
end

=begin
output: 

infinite loop
=end

=================================================Ruby Methods================================================= 
Ruby methods are very similar to functions in any other programming language. Ruby methods are used to bundle one or more repeatable statements into a single unit.

Method names should begin with a lowercase letter. If you begin a method name with an uppercase letter, Ruby might think that it is a constant and hence can parse the call incorrectly.

Methods should be defined before calling them, otherwise Ruby will raise an exception for undefined method invoking.

Syntax :

1.simple method syntax With no parameter :
 
	def method_name 
          expr..
	end

2.You can represent a method that accepts parameters like this :
	
	def method_name (var1, var2)
  	  expr..
	end
3.You can set default values for the parameters, which will be used if method is called without passing the required parameters :

	def method_name (var1 = value1, var2 = value2)
	   expr..
	end
	
4.Whenever you call the simple method, you write only the method name as follows:
	
	method_name
	
5.when you call a method with parameters, you write the method name along with the parameters, such as 

	method_name 25, 30


6.Return Values from Methods:

Every method in Ruby returns a value by default. This returned value will be the value of the last statement. For example

methdo: 

def return_method
  i = 1
  j = 2
  k =100
end

will return the last declare variable k

7.Ruby return Statement: The return statement in ruby is used to return one or more values from a Ruby Method.

syntax : return [expr[`,' expr...]]


If more than two expressions are given, the array containing these values will be the return value. If no expression given, nil will be the return value.


Example : return   or   return 1,2,3    or  return 13


8.Variable Number of Parameters

def sample(*test)
  puts"the number of parameter is : #{test.length}"
  for i in 0...test.length
    puts "The parameters are : #{test[i]}"
  end
end
sample "Aman","6","M"
sample "Niharika","7","F"

=begin
output:
ruby  variable_num_parameter.rb
the number of parameter is : 3
The parameters are : Aman
The parameters are : 6
The parameters are : M
the number of parameter is : 3
The parameters are : Niharika
The parameters are : 7
The parameters are : F

=end

13.class Methods:When a method is defined outside of the class definition, the method is marked as private by default. On the other hand, the methods defined in the class definition are marked as public by default. The default visibility and the private mark of the methods can be changed by public or private of the Module.

Whenever you want to access a method of a class, you first need to instantiate the class. Then, using the object, you can access any member of the class.

Ruby gives you a way to access a method without instantiating a class. Let us see how a class method is declared and accessed 


code : 

class Accounts
   def reading_charge
   end
   def Accounts.return_date
   end
end


See how the method return_date is declared. It is declared with the class name followed by a period, which is followed by the name of the method. You can access this class method directly as follows −

							Accounts.return_date

To access this method, you need not create objects of the class Accounts.

=========================================================Blocks========================================
A block consists of chunks of code.
You assign a name to a block.
The code in the block is always enclosed within braces ({}).
A block is always invoked from a function with the same name as that of the block. This means that if you have a block with the name test, then you use the function test to invoke this block.
You invoke a block by using the yield statement.


Syntax : 

block_name {
   statement1
   statement2
   ..........
}


example :
 def test
  puts"you are in the method"
  yield
  puts"you are again in the method"
  yield
end
test {
  puts"you are in the block"
}


=begin
output:

you are in the method
you are in the block
you are again in the method
you are in the block

=end

Example :

def test
  yield 5
  puts "You are in the method test"
  yield 100
end
test{
  |i| puts"You are in the block #{i}"
}

=begin
output :

ruby yieldtest.rb
You are in the block 5
You are in the method test
You are in the block 100

=end


Example :
If you want to pass more than one parameters, then the yield statement becomes −

yield a, b

and the block is −

test {|a, b| statement}


1.Blocks and Methods:

def test
  yield
end
test{

  puts "Hello world"
}
test{
  puts "HI another block"
}

=begin 
output:

ruby  block_and_methods.rb
Hello world
HI another block
=end

2.Begin and End block : Every Ruby source file can declare blocks of code to be run as the file is being loaded (the BEGIN blocks) and after the program has finished executing (the END blocks).



BEGIN {
  # begin block code
  puts "BEGIN code block"
}
END {
  
  #END block code
  puts "END code block"
  
}

#MAIN block code
puts "MAIN code block"


=begin
output :

BEGIN code block
MAIN code block
END code block

=end


======================================================================Modules=========================================================
1.Modules are a way of grouping together methods, classes, and constants. Modules give you two major benefits.

    Modules provide a namespace and prevent name clashes.

    Modules implement the mixin facility.

Modules define a namespace, a sandbox in which your methods and constants can play without having to worry about being stepped on by other methods and constants.
Syntax

module Identifier
   statement1
   statement2
   ...........
end

2.Ruby require Statement

The require statement is similar to the include statement of C and C++ and the import statement of Java. If a third program wants to use any defined module, it can simply load the module files using the Ruby require statement −
Syntax

require filename

3.Ruby include Statement

You can embed a module in a class. To embed a module in a class, you use the include statement in the class −
Syntax

include modulename

If a module is defined in a separate file, then it is required to include that file using require statement before embedding module in a class.


module.rb

module Usefull
  def sayhi(name)
    puts"Hello How are you #{name}"
  end
  def saybye(name)
    puts"By By see you again #{name}"
  end
end

require.rb

require_relative "module.rb"
include Usefull

Usefull.sayhi("Aman")
Usefull.saybye("Rohit")
=begin 
output:

Hello How are you Aman
By By see you again Rohit

=end 

4.Mixin : ruby does't support multiple inheritence directly but we can using mixin It is a concept not keyword.

#module A
module A
  def a1
    puts "we are in a1 method of module A"
  end

  def a2
    puts "we are in a2 method of module B"
  end

end
#module B
module B
  def b1
    puts "we are in b1 module of B"
  end

  def b2
    puts "we are in b2 module of B"
  end

end

class Sample
  include A
  include B
end

s = Sample.new
s.a1
s.a2
s.b1
s.b2
                                                                                                                                    1,1           Top


ruby mixin.rb
we are in a1 method of module A
we are in a2 method of module B
we are in b1 module of B
we are in b2 module of B

==============================String==================================
1.Expression Substitution
x,y,z = 12,36,72
puts "The value of x is #{x}"
puts "The value of x and y is #{x + y}"
puts "The average was #{(x+y+z)/3}"

=begin 
ruby expression.rb

The value of x is 12
The value of x and y is 48
The average was 40

=end

2.General Delimited Strings

%{Ruby is fun.}  equivalent to "Ruby is fun."
%Q{ Ruby is fun. } equivalent to " Ruby is fun. "
%q[Ruby is fun.]  equivalent to a single-quoted string
%x!ls! equivalent to back tick command output `ls`


2.string builtin:

We need to have an instance of String object to call a String method. Following is the way to create an instance of String object −

new [String.new(str = "")]

code : 
myStr = String.new("THIS IS TEST")
foo = myStr.downcase

puts "#{foo}"

output : this is test

====================================================Array================================================
1.Declaring and defining of Array 

#calculating size of the array and learning 
#and creating and defining of array 

name  =  Array.new(20)
puts name.size #this return 20
puts name.length #this also returns 20


2.Assigning values through array '

names = Array.new(4,"mac")
puts "#{names}"

=begin 
ruby assigning_values.rb
["mac", "mac", "mac", "mac"]
=end 
--------------------------------
nums  =Array.new(10) { |e| e = e*2}
puts "#{nums}"

=begin 
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

=end

3.

=========================================27th October==============================================================

1.Hashes : Hash is the collection of key and value pair.

syntax :			 months = Hash.new

You can also use new to create a hash with a default value, which is otherwise just nil −

			    months = Hash.new( "month" )

					or

			    months = Hash.new "month"

When you access any key in a hash that has a default value, if the key or value doesn't exist, accessing the hash will return the default value 

2.Time and Date : to show date and time in ruby there is multiple functionality available in  ruby.

3.Ranges:Ranges occur everywhere: January to December, 0 to 9, lines 50 through 67, and so on. Ruby supports ranges and allows us to use ranges in a variety of ways −

    Ranges as Sequences
    Ranges as Conditions
    Ranges as Intervals
 
 example:    
 (1..5)        #==> 1, 2, 3, 4, 5
(1...5)       #==> 1, 2, 3, 4
('a'..'d')    #==> 'a', 'b', 'c', 'd'



4.Iterators:terators are nothing but methods supported by collections. Objects that store a group of data members are called collections. In Ruby, arrays and hashes can be termed collections.
Syntax

1.each iterator:
		collection.each do |variable|
   			code
		end

2.Collect iterator:
syntax :
	collection = collection.collect



5.File I/O: Ruby provides a whole set of I/O-related methods implemented in the Kernel module. All the I/O methods are derived from the class IO.

1.puts : The puts statement instructs the program to display the value stored in the variable. This will add a new line at the end of each line it writes.
Example


#!/usr/bin/ruby

val1 = "This is variable one"
val2 = "This is variable two"
puts val1
puts val2
 
output:

This is variable one
This is variable two
2.get : The gets statement can be used to take any input from the user from standard screen called STDIN.
Example

The following code shows you how to use the gets statement. This code will prompt the user to enter a value, which will be stored in a variable val and finally will be printed on STDOUT.



puts "Enter a value :"
val = gets
puts val

This will produce the following result −

Enter a value :
This is entered value
This is entered value

3.putc :Unlike the puts statement, which outputs the entire string onto the screen, the putc statement can be used to output one character at a time.
Example

The output of the following code is just the character H −
Live Demo



str = "Hello Ruby!"
putc str

This will produce the following result −

H

4.print :The print statement is similar to the puts statement. The only difference is that the puts statement goes to the next line after printing the contents, whereas with the print statement the cursor is positioned on the same line.
Example


print "Hello World"
print "Good Morning"

This will produce the following result −

Hello WorldGood Morning



